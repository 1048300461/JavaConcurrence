package JavaConcurrence.CAS;

public class CASLearn {
    //java.util.concurrent.atomic

    //CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。执行
    //CAS操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自
    //动将该位置值更新为新值。否则，处理器不做任何操作。

    //CAS存在的三大问题：
    //1 ABA问题
        //因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有
        //发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用
        //CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。
    //2 循环时间长开销大
        //循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。
    //3 只能保证一个共享变量的原子操作
        //只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以
        //使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS
        //就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就
        //是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝
        //2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了
        //AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一
        //个对象里来进行CAS操作。
}
