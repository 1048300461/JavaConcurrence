package com.example.javaconcurrence.JVM;

public class JVMLearn {
    // 对象的创建
    //1.虚拟机遇到一个new指令时，首先将去检查这个指令的参数是否能在常量池中定
    //位到一个类的符号引用；
    //2.检查这个符号引用代表的类是否已经被加载，解析和初始化过。如果没有，那必
    //须先执行响应的类加载过程；
    //3.在类加载检查功通过后，为新生对象分配内存。对象所需的内存大小在类加载完
    //成后便可完全确定。

    // 对象的内存布局
        //对象头：第一部分：对象自身的运行时数据，如哈希码，GC分代年龄，
            //锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等，这部分数据的长度在32
            //位和64位的虚拟机中分别为32 bit和64 bit，官方称它为“Mark Word”。
            //第二部分：类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确
            //定这个对象是哪个类的实例。如果对象是一个java数组，那在对象头中还必须有一
            //块用于记录数组长度的数据。

        //实例数据：是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。

        //对齐填充：

    // 对象的访问定位：Java程序需要通过栈上了reference数据来操作堆上的具体对象。
    //目前主流的访问方式有使用句柄和直接指针两种。
        //句柄访问：
            //Java堆中会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地
            //址，而句柄中包含了对实例数据与类型数据的各自具体的地址信息。
        //直接指针访问：
            //reference中存储的直接就是对象地址。

    // Java内存区域
        //方法区（共有）：其中包含常量池：用户存放编译器生成的各种字面量和符号引用。用户存储已被虚拟机加载的类信息，常量，静态常量，即时编译
        //器编译后的代码等数据。异常状态 OutOfMemoryError

        //堆（公有）： 是JVM所管理的内存中最大的一块。唯一目的就是存放实例对象，几
        //乎所有的对象实例都在这里分配。Java堆是垃圾收集器管理的主要区域，因此很多
        //时候也被称为“GC堆”。异常状态 OutOfMemoryError

        //虚拟机栈（线程私有）： 描述的是java方法执行的内存模型：每个方法在执行时都
        //会创建一个栈帧，用户存储局部变量表，操作数栈，动态连接，方法出口等信息。
        //每一个方法从调用直至完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的
        //过程。 对这个区域定义了两种异常状态 OutOfMemoryError StackOverflowError

        //本地方法栈（线程私有）: 与虚拟机栈所发挥的作用相似。它们之间的区别不过是
        //虚拟机栈为虚拟机执行java方法，而本地方法栈为虚拟机使用到的Native方法服务。

        //程序计数器（线程私有）： 一块较小的内存，当前线程所执行的字节码的行号指示
        //器。字节码解释器工作时，就是通过改变这个计数器的值来选取下一条需要执行的
        //字节码指令。

    // Java内存模型
        //目的：屏蔽掉各种硬件和操作系统的内存访问差异，以实现让java
        //程序在各种平台下都能达到一致的内存访问效果。

    // 类的生命周期：加载、（验证、准备、解析）连接、初始化、使用和卸载

    // 触发类加载的条件
        //①.遇到new,getstatic,putstatic或invokestatic这4条字节码指令时，如果类没有进行
        //过初始化，则需要先触发初始化。生成这4条指令的最常见的Java代码场景是：使
        //用new关键字实例化对象的时候，读取或设置一个类的静态字段的时候（被final修
        //饰，已在编译期把结果放入常量池的静态字段除外），以及调用一个类的静态方法
        //的时候。
        //②.使用java.lang.reflect包的方法对类进行反射调用的时候。
        //③.当初始化一个类的时候，发现其父类还没有进行过初始化，则需要先出发父类的
        //初始化。
        //④.当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个
        //类），虚拟机会先初始化这个主类。
        //⑤.当使用JDK1.7的动态语言支持时，如果一
        //个 java.lang.invoke.MethodHandle 实例最后的解析结
        //果 REF_getStatic,REF_putStatic,REF_invokeStatic 的方法句柄，并且这个
        //方法句柄所对应的类没有进行初始化，则需要先出发初始化。

    //如何判断对象是否已死
        //1 引用计数法：每当有一个地方引用它时，计数器值就加1；当引用
        //失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能被再使用的。
        //主流的JVM里面没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象间的互循环引用的问题。

        //2 可达性分析算法：通过一些列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索
        //所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时（就是从
        //GC Roots 到这个对象是不可达），则证明此对象是不可用的。所以它们会被判定
        //为可回收对象（例如图B中的对象既是不可达的）。
        //方法运行时，方法中引用的对象；类的静态变量引用的对象；类中常量
        //引用的对象；Native方法中引用的对象

    //判断对象是否存活与“引用”有关
        // 强引用：就是指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类
        //的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。

        // 软引用：用来描述一些还有用但并非必须的对象。在系统将要发生内存溢出异常之
        //前，将会把这些对象列进回收范围之中进行第二次回收。

        // 弱引用：用户描述非必须对象的。被弱引用关联的对象只能生存到下一次垃圾收集
        //发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用
        //关联的对象。

        // 虚引用：一个对象是否有虚引用存在，完全不会对其生存时间构成影响，也无法通
        //过虚引用来取得一个对象实例。为一个对象设置虚引用的唯一目的就是能在这个对
        //象被收集器回收时刻得到一个系统通知。
}
